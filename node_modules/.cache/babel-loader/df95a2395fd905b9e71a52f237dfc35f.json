{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/hb-2547/prerna/assignement/pm-tool/client-using-saga/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport { GraphQLIncludeDirective, GraphQLSkipDirective } from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  var fields = new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  var subFieldNodes = new Map();\n  var visitedFragmentNames = new Set();\n\n  var _iterator = _createForOfIteratorHelper(fieldNodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.selectionSet) {\n        collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  var _iterator2 = _createForOfIteratorHelper(selectionSet.selections),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var selection = _step2.value;\n\n      switch (selection.kind) {\n        case Kind.FIELD:\n          {\n            if (!shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n\n            var name = getFieldEntryKey(selection);\n            var fieldList = fields.get(name);\n\n            if (fieldList !== undefined) {\n              fieldList.push(selection);\n            } else {\n              fields.set(name, [selection]);\n            }\n\n            break;\n          }\n\n        case Kind.INLINE_FRAGMENT:\n          {\n            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n              continue;\n            }\n\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n\n        case Kind.FRAGMENT_SPREAD:\n          {\n            var fragName = selection.name.value;\n\n            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n\n            visitedFragmentNames.add(fragName);\n            var fragment = fragments[fragName];\n\n            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n              continue;\n            }\n\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}","map":null,"metadata":{},"sourceType":"module"}