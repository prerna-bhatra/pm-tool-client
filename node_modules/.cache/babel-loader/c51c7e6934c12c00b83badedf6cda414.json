{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/hb-2547/prerna/assignement/pm-tool/client-using-saga/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\n\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    var _iterator = _createForOfIteratorHelper(spreadNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var spreadNode = _step.value;\n        var spreadName = spreadNode.name.value;\n        var cycleIndex = spreadPathIndexByName[spreadName];\n        spreadPath.push(spreadNode);\n\n        if (cycleIndex === undefined) {\n          var spreadFragment = context.getFragment(spreadName);\n\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        } else {\n          var cyclePath = spreadPath.slice(cycleIndex);\n          var viaPath = cyclePath.slice(0, -1).map(function (s) {\n            return '\"' + s.name.value + '\"';\n          }).join(', ');\n          context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), {\n            nodes: cyclePath\n          }));\n        }\n\n        spreadPath.pop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}